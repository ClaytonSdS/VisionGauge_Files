from ultralytics import YOLO
import cv2
import numpy as np
import torch
import pandas as pd
import matplotlib.pyplot as plt
from Arch import NewDirectModel_Inference as NDM

pd.options.display.max_columns = None
pd.options.display.max_colwidth = None
pd.options.display.width = 0

# ======================================================
# FUNÇÃO: Zero-padding para tornar a imagem quadrada
# ======================================================
def pad_to_square_center(img):
    h, w = img.shape[:2]
    size = max(h, w)
    padded = np.zeros((size, size, 3), dtype=img.dtype)
    y_off = (size - h) // 2
    x_off = (size - w) // 2
    padded[y_off:y_off + h, x_off:x_off + w] = img
    return padded

# ---------------- Inicialização do modelo ----------------
Segmentation = YOLO("models/SegARC_v04_lr0.0001_5k/weights/best.pt")

Regressor = NDM("resnet").load_model("models\\RegArc\\MIX\\resnet_120x120_2025_12_05_HashSplit_Unfreeze_NoHead_ADAMW.pth")
best1 = torch.load('models\\RegArc\\MIX\\resnet_120x120_2025_12_05_HashSplit_Unfreeze_NoHead_ADAMW.pth', map_location='cpu')["best_val_loss"]
print(f"Regresso1 best loss: {best1}")


Regressor_2 = NDM("efficientnet_lite").load_model("models\RegArc\MIX\efficientnet_lite_120x120_2025_12_04_HashSplit_UnfreezeAll_NoHead_ADAMW_retrained.pth")
best2 = torch.load('models\\RegArc\\MIX\\efficientnet_lite_120x120_2025_12_04_HashSplit_UnfreezeAll_NoHead_ADAMW_retrained.pth', map_location='cpu')["best_val_loss"]
print(f"Regressor 2 best loss: {best2}")


# ======================================================
#  PIPELINE COM IMAGENS CRUAS
# ======================================================

paths = [
    r"dataset\dataset_od\6k\test\11.1\image_resized_4735_png.rf.e4a4842315253a922b6d0e0139e26e19.jpg",
]

out = Segmentation.predict(paths, conf=0.5)

numero_de_imgs = len(out)
boxes_list = [out[i].boxes.xyxy.cpu().numpy() for i in range(numero_de_imgs)]

df_localizer = pd.DataFrame(columns=[
    "boxes", "path", "box_xmin", "box_ymin", "box_xmax", "box_ymax", "pred_height_cm"
])

paths_count = 0

for boxes in boxes_list:
    n_boxes = boxes.shape[0]
    img_full = cv2.imread(paths[paths_count])
    img_full_square = pad_to_square_center(img_full) 

    images_raw = []
    row_indices = []

    # cria linhas do DF
    for i in range(n_boxes):
        df_localizer.loc[len(df_localizer)] = {
            "boxes": i,
            "path": paths[paths_count],
            "box_xmin": None,
            "box_ymin": None,
            "box_xmax": None,
            "box_ymax": None,
            "pred_height_cm": None
        }
        row_indices.append(len(df_localizer) - 1)

    # extrai crops crus
    for i in range(n_boxes):
        xmin, ymin, xmax, ymax = boxes[i].astype(int)

        df_localizer.loc[row_indices[i], ["box_xmin","box_ymin","box_xmax","box_ymax"]] = \
            [xmin, ymin, xmax, ymax]

        crop = img_full[ymin:ymax, xmin:xmax]
        crop_square = pad_to_square_center(crop)

        # printar o tamanho do crop
        print(f"Crop {i} size: {crop.shape} | crop square size: {crop_square.shape} | |height-width| : {abs(crop.shape[0]-crop.shape[1])}")



        """
        plt.figure(figsize=(4, 4))
        plt.imshow(cv2.cvtColor(crop_square, cv2.COLOR_BGR2RGB))
        plt.axis("off")
        plt.show()
        """

        images_raw.append(crop_square)

    print("\nNúmero de crops para predição:", len(images_raw))

    # ======================================================
    #   PREDIÇÕES
    # ======================================================

    # R1 e R2 usam os crops
    if len(images_raw) == 0:
        preds1 = np.zeros((0,), dtype=float)
        preds2 = np.zeros((0,), dtype=float)
    else:
        preds1 = Regressor.predict(images_raw)
        preds2 = Regressor_2.predict(images_raw)

    # R3 usa a imagem ORIGINAL (zero padded)
    #preds3 = Regressor_2.predict([img_full_square])[0]

    print("\nPREDIÇÕES R1:", preds1)
    print("PREDIÇÕES R2:", preds2)
    #print("PREDIÇÃO R3 (imagem bruta):", preds3, "\n")

    df_localizer.loc[row_indices, "pred_height_cm"] = preds1

    # ======================================================
    #   DESENHO — R1 e R2
    # ======================================================

    img_r1 = img_full.copy()
    img_r2 = img_full.copy()

    for i in range(n_boxes):
        xmin = int(df_localizer.loc[row_indices[i], "box_xmin"])
        ymin = int(df_localizer.loc[row_indices[i], "box_ymin"])
        xmax = int(df_localizer.loc[row_indices[i], "box_xmax"])
        ymax = int(df_localizer.loc[row_indices[i], "box_ymax"])

        r1 = float(preds1[i])
        r2 = float(preds2[i])
        #r3 = float(preds3)

        label = f"R1: {r1:.2f} | R2: {r2:.2f}"

        cv2.rectangle(img_r1, (xmin, ymin), (xmax, ymax), (0,255,0), 2)
        cv2.putText(img_r1, label, (xmin, ymax - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)

        cv2.rectangle(img_r2, (xmin, ymin), (xmax, ymax), (255,0,0), 2)
        cv2.putText(img_r2, label, (xmin, ymax - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,0,0), 2)

    # ======================================================
    #   PLOT LADO A LADO
    # ======================================================

    fig, ax = plt.subplots(1, 2, figsize=(18, 8))

    ax[0].imshow(cv2.cvtColor(img_r1, cv2.COLOR_BGR2RGB))
    ax[0].set_title("Regressor 1 (R1)")
    ax[0].axis("off")

    ax[1].imshow(cv2.cvtColor(img_r2, cv2.COLOR_BGR2RGB))
    ax[1].set_title("Regressor 2 (R2)")
    ax[1].axis("off")

    path_parts = paths[paths_count].split("\\")
    folder = path_parts[1].upper()
    filename = path_parts[-1]

    plt.suptitle(f"{folder} | {filename}", fontsize=16)

    plt.tight_layout()
    plt.show()

    paths_count += 1

print(df_localizer)
